// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ORDERBOOK_MD_H_
#define FLATBUFFERS_GENERATED_ORDERBOOK_MD_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

namespace md {

struct FBBookDeltaEvent;
struct FBBookDeltaEventBuilder;
struct FBBookDeltaEventT;

struct OrderMsgOrder;
struct OrderMsgOrderBuilder;
struct OrderMsgOrderT;

struct OrderMsgLevel;
struct OrderMsgLevelBuilder;
struct OrderMsgLevelT;

struct DeltaBatch;
struct DeltaBatchBuilder;
struct DeltaBatchT;

struct OrderBookSnapshot;
struct OrderBookSnapshotBuilder;
struct OrderBookSnapshotT;

struct Envelope;
struct EnvelopeBuilder;
struct EnvelopeT;

enum Kind : int8_t {
  Kind_Add = 0,
  Kind_Modify = 1,
  Kind_Remove = 2,
  Kind_Trade = 3,
  Kind_MIN = Kind_Add,
  Kind_MAX = Kind_Trade
};

inline const Kind (&EnumValuesKind())[4] {
  static const Kind values[] = {
    Kind_Add,
    Kind_Modify,
    Kind_Remove,
    Kind_Trade
  };
  return values;
}

inline const char * const *EnumNamesKind() {
  static const char * const names[5] = {
    "Add",
    "Modify",
    "Remove",
    "Trade",
    nullptr
  };
  return names;
}

inline const char *EnumNameKind(Kind e) {
  if (::flatbuffers::IsOutRange(e, Kind_Add, Kind_Trade)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesKind()[index];
}

enum Side : int8_t {
  Side_Buy = 0,
  Side_Sell = 1,
  Side_MIN = Side_Buy,
  Side_MAX = Side_Sell
};

inline const Side (&EnumValuesSide())[2] {
  static const Side values[] = {
    Side_Buy,
    Side_Sell
  };
  return values;
}

inline const char * const *EnumNamesSide() {
  static const char * const names[3] = {
    "Buy",
    "Sell",
    nullptr
  };
  return names;
}

inline const char *EnumNameSide(Side e) {
  if (::flatbuffers::IsOutRange(e, Side_Buy, Side_Sell)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSide()[index];
}

enum BookMsg : uint8_t {
  BookMsg_NONE = 0,
  BookMsg_DeltaBatch = 1,
  BookMsg_OrderBookSnapshot = 2,
  BookMsg_MIN = BookMsg_NONE,
  BookMsg_MAX = BookMsg_OrderBookSnapshot
};

inline const BookMsg (&EnumValuesBookMsg())[3] {
  static const BookMsg values[] = {
    BookMsg_NONE,
    BookMsg_DeltaBatch,
    BookMsg_OrderBookSnapshot
  };
  return values;
}

inline const char * const *EnumNamesBookMsg() {
  static const char * const names[4] = {
    "NONE",
    "DeltaBatch",
    "OrderBookSnapshot",
    nullptr
  };
  return names;
}

inline const char *EnumNameBookMsg(BookMsg e) {
  if (::flatbuffers::IsOutRange(e, BookMsg_NONE, BookMsg_OrderBookSnapshot)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBookMsg()[index];
}

template<typename T> struct BookMsgTraits {
  static const BookMsg enum_value = BookMsg_NONE;
};

template<> struct BookMsgTraits<md::DeltaBatch> {
  static const BookMsg enum_value = BookMsg_DeltaBatch;
};

template<> struct BookMsgTraits<md::OrderBookSnapshot> {
  static const BookMsg enum_value = BookMsg_OrderBookSnapshot;
};

template<typename T> struct BookMsgUnionTraits {
  static const BookMsg enum_value = BookMsg_NONE;
};

template<> struct BookMsgUnionTraits<md::DeltaBatchT> {
  static const BookMsg enum_value = BookMsg_DeltaBatch;
};

template<> struct BookMsgUnionTraits<md::OrderBookSnapshotT> {
  static const BookMsg enum_value = BookMsg_OrderBookSnapshot;
};

struct BookMsgUnion {
  BookMsg type;
  void *value;

  BookMsgUnion() : type(BookMsg_NONE), value(nullptr) {}
  BookMsgUnion(BookMsgUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(BookMsg_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  BookMsgUnion(const BookMsgUnion &);
  BookMsgUnion &operator=(const BookMsgUnion &u)
    { BookMsgUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  BookMsgUnion &operator=(BookMsgUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~BookMsgUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = BookMsgUnionTraits<RT>::enum_value;
    if (type != BookMsg_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, BookMsg type, const ::flatbuffers::resolver_function_t *resolver);
  ::flatbuffers::Offset<void> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  md::DeltaBatchT *AsDeltaBatch() {
    return type == BookMsg_DeltaBatch ?
      reinterpret_cast<md::DeltaBatchT *>(value) : nullptr;
  }
  const md::DeltaBatchT *AsDeltaBatch() const {
    return type == BookMsg_DeltaBatch ?
      reinterpret_cast<const md::DeltaBatchT *>(value) : nullptr;
  }
  md::OrderBookSnapshotT *AsOrderBookSnapshot() {
    return type == BookMsg_OrderBookSnapshot ?
      reinterpret_cast<md::OrderBookSnapshotT *>(value) : nullptr;
  }
  const md::OrderBookSnapshotT *AsOrderBookSnapshot() const {
    return type == BookMsg_OrderBookSnapshot ?
      reinterpret_cast<const md::OrderBookSnapshotT *>(value) : nullptr;
  }
};

bool VerifyBookMsg(::flatbuffers::Verifier &verifier, const void *obj, BookMsg type);
bool VerifyBookMsgVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

struct FBBookDeltaEventT : public ::flatbuffers::NativeTable {
  typedef FBBookDeltaEvent TableType;
  md::Kind kind = md::Kind_Add;
  uint64_t order_id = 0;
  uint64_t price = 0;
  uint32_t qty = 0;
  md::Side side = md::Side_Buy;
  uint64_t seq = 0;
};

struct FBBookDeltaEvent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FBBookDeltaEventT NativeTableType;
  typedef FBBookDeltaEventBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KIND = 4,
    VT_ORDER_ID = 6,
    VT_PRICE = 8,
    VT_QTY = 10,
    VT_SIDE = 12,
    VT_SEQ = 14
  };
  md::Kind kind() const {
    return static_cast<md::Kind>(GetField<int8_t>(VT_KIND, 0));
  }
  uint64_t order_id() const {
    return GetField<uint64_t>(VT_ORDER_ID, 0);
  }
  uint64_t price() const {
    return GetField<uint64_t>(VT_PRICE, 0);
  }
  uint32_t qty() const {
    return GetField<uint32_t>(VT_QTY, 0);
  }
  md::Side side() const {
    return static_cast<md::Side>(GetField<int8_t>(VT_SIDE, 0));
  }
  uint64_t seq() const {
    return GetField<uint64_t>(VT_SEQ, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_KIND, 1) &&
           VerifyField<uint64_t>(verifier, VT_ORDER_ID, 8) &&
           VerifyField<uint64_t>(verifier, VT_PRICE, 8) &&
           VerifyField<uint32_t>(verifier, VT_QTY, 4) &&
           VerifyField<int8_t>(verifier, VT_SIDE, 1) &&
           VerifyField<uint64_t>(verifier, VT_SEQ, 8) &&
           verifier.EndTable();
  }
  FBBookDeltaEventT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FBBookDeltaEventT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<FBBookDeltaEvent> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FBBookDeltaEventT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FBBookDeltaEventBuilder {
  typedef FBBookDeltaEvent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_kind(md::Kind kind) {
    fbb_.AddElement<int8_t>(FBBookDeltaEvent::VT_KIND, static_cast<int8_t>(kind), 0);
  }
  void add_order_id(uint64_t order_id) {
    fbb_.AddElement<uint64_t>(FBBookDeltaEvent::VT_ORDER_ID, order_id, 0);
  }
  void add_price(uint64_t price) {
    fbb_.AddElement<uint64_t>(FBBookDeltaEvent::VT_PRICE, price, 0);
  }
  void add_qty(uint32_t qty) {
    fbb_.AddElement<uint32_t>(FBBookDeltaEvent::VT_QTY, qty, 0);
  }
  void add_side(md::Side side) {
    fbb_.AddElement<int8_t>(FBBookDeltaEvent::VT_SIDE, static_cast<int8_t>(side), 0);
  }
  void add_seq(uint64_t seq) {
    fbb_.AddElement<uint64_t>(FBBookDeltaEvent::VT_SEQ, seq, 0);
  }
  explicit FBBookDeltaEventBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FBBookDeltaEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FBBookDeltaEvent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FBBookDeltaEvent> CreateFBBookDeltaEvent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    md::Kind kind = md::Kind_Add,
    uint64_t order_id = 0,
    uint64_t price = 0,
    uint32_t qty = 0,
    md::Side side = md::Side_Buy,
    uint64_t seq = 0) {
  FBBookDeltaEventBuilder builder_(_fbb);
  builder_.add_seq(seq);
  builder_.add_price(price);
  builder_.add_order_id(order_id);
  builder_.add_qty(qty);
  builder_.add_side(side);
  builder_.add_kind(kind);
  return builder_.Finish();
}

::flatbuffers::Offset<FBBookDeltaEvent> CreateFBBookDeltaEvent(::flatbuffers::FlatBufferBuilder &_fbb, const FBBookDeltaEventT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OrderMsgOrderT : public ::flatbuffers::NativeTable {
  typedef OrderMsgOrder TableType;
  uint64_t id = 0;
  uint32_t qty = 0;
  md::Side side = md::Side_Buy;
};

struct OrderMsgOrder FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OrderMsgOrderT NativeTableType;
  typedef OrderMsgOrderBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_QTY = 6,
    VT_SIDE = 8
  };
  uint64_t id() const {
    return GetField<uint64_t>(VT_ID, 0);
  }
  uint32_t qty() const {
    return GetField<uint32_t>(VT_QTY, 0);
  }
  md::Side side() const {
    return static_cast<md::Side>(GetField<int8_t>(VT_SIDE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ID, 8) &&
           VerifyField<uint32_t>(verifier, VT_QTY, 4) &&
           VerifyField<int8_t>(verifier, VT_SIDE, 1) &&
           verifier.EndTable();
  }
  OrderMsgOrderT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OrderMsgOrderT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<OrderMsgOrder> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const OrderMsgOrderT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OrderMsgOrderBuilder {
  typedef OrderMsgOrder Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(uint64_t id) {
    fbb_.AddElement<uint64_t>(OrderMsgOrder::VT_ID, id, 0);
  }
  void add_qty(uint32_t qty) {
    fbb_.AddElement<uint32_t>(OrderMsgOrder::VT_QTY, qty, 0);
  }
  void add_side(md::Side side) {
    fbb_.AddElement<int8_t>(OrderMsgOrder::VT_SIDE, static_cast<int8_t>(side), 0);
  }
  explicit OrderMsgOrderBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OrderMsgOrder> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OrderMsgOrder>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OrderMsgOrder> CreateOrderMsgOrder(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    uint32_t qty = 0,
    md::Side side = md::Side_Buy) {
  OrderMsgOrderBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_qty(qty);
  builder_.add_side(side);
  return builder_.Finish();
}

::flatbuffers::Offset<OrderMsgOrder> CreateOrderMsgOrder(::flatbuffers::FlatBufferBuilder &_fbb, const OrderMsgOrderT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OrderMsgLevelT : public ::flatbuffers::NativeTable {
  typedef OrderMsgLevel TableType;
  uint64_t price = 0;
  std::vector<std::unique_ptr<md::OrderMsgOrderT>> orders{};
  OrderMsgLevelT() = default;
  OrderMsgLevelT(const OrderMsgLevelT &o);
  OrderMsgLevelT(OrderMsgLevelT&&) FLATBUFFERS_NOEXCEPT = default;
  OrderMsgLevelT &operator=(OrderMsgLevelT o) FLATBUFFERS_NOEXCEPT;
};

struct OrderMsgLevel FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OrderMsgLevelT NativeTableType;
  typedef OrderMsgLevelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PRICE = 4,
    VT_ORDERS = 6
  };
  uint64_t price() const {
    return GetField<uint64_t>(VT_PRICE, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<md::OrderMsgOrder>> *orders() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<md::OrderMsgOrder>> *>(VT_ORDERS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PRICE, 8) &&
           VerifyOffset(verifier, VT_ORDERS) &&
           verifier.VerifyVector(orders()) &&
           verifier.VerifyVectorOfTables(orders()) &&
           verifier.EndTable();
  }
  OrderMsgLevelT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OrderMsgLevelT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<OrderMsgLevel> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const OrderMsgLevelT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OrderMsgLevelBuilder {
  typedef OrderMsgLevel Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_price(uint64_t price) {
    fbb_.AddElement<uint64_t>(OrderMsgLevel::VT_PRICE, price, 0);
  }
  void add_orders(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<md::OrderMsgOrder>>> orders) {
    fbb_.AddOffset(OrderMsgLevel::VT_ORDERS, orders);
  }
  explicit OrderMsgLevelBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OrderMsgLevel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OrderMsgLevel>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OrderMsgLevel> CreateOrderMsgLevel(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t price = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<md::OrderMsgOrder>>> orders = 0) {
  OrderMsgLevelBuilder builder_(_fbb);
  builder_.add_price(price);
  builder_.add_orders(orders);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<OrderMsgLevel> CreateOrderMsgLevelDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t price = 0,
    const std::vector<::flatbuffers::Offset<md::OrderMsgOrder>> *orders = nullptr) {
  auto orders__ = orders ? _fbb.CreateVector<::flatbuffers::Offset<md::OrderMsgOrder>>(*orders) : 0;
  return md::CreateOrderMsgLevel(
      _fbb,
      price,
      orders__);
}

::flatbuffers::Offset<OrderMsgLevel> CreateOrderMsgLevel(::flatbuffers::FlatBufferBuilder &_fbb, const OrderMsgLevelT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DeltaBatchT : public ::flatbuffers::NativeTable {
  typedef DeltaBatch TableType;
  std::string symbol{};
  uint64_t seq_start = 0;
  uint64_t seq_end = 0;
  std::vector<std::unique_ptr<md::FBBookDeltaEventT>> events{};
  DeltaBatchT() = default;
  DeltaBatchT(const DeltaBatchT &o);
  DeltaBatchT(DeltaBatchT&&) FLATBUFFERS_NOEXCEPT = default;
  DeltaBatchT &operator=(DeltaBatchT o) FLATBUFFERS_NOEXCEPT;
};

struct DeltaBatch FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DeltaBatchT NativeTableType;
  typedef DeltaBatchBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SYMBOL = 4,
    VT_SEQ_START = 6,
    VT_SEQ_END = 8,
    VT_EVENTS = 10
  };
  const ::flatbuffers::String *symbol() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SYMBOL);
  }
  uint64_t seq_start() const {
    return GetField<uint64_t>(VT_SEQ_START, 0);
  }
  uint64_t seq_end() const {
    return GetField<uint64_t>(VT_SEQ_END, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<md::FBBookDeltaEvent>> *events() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<md::FBBookDeltaEvent>> *>(VT_EVENTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SYMBOL) &&
           verifier.VerifyString(symbol()) &&
           VerifyField<uint64_t>(verifier, VT_SEQ_START, 8) &&
           VerifyField<uint64_t>(verifier, VT_SEQ_END, 8) &&
           VerifyOffset(verifier, VT_EVENTS) &&
           verifier.VerifyVector(events()) &&
           verifier.VerifyVectorOfTables(events()) &&
           verifier.EndTable();
  }
  DeltaBatchT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DeltaBatchT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<DeltaBatch> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DeltaBatchT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DeltaBatchBuilder {
  typedef DeltaBatch Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_symbol(::flatbuffers::Offset<::flatbuffers::String> symbol) {
    fbb_.AddOffset(DeltaBatch::VT_SYMBOL, symbol);
  }
  void add_seq_start(uint64_t seq_start) {
    fbb_.AddElement<uint64_t>(DeltaBatch::VT_SEQ_START, seq_start, 0);
  }
  void add_seq_end(uint64_t seq_end) {
    fbb_.AddElement<uint64_t>(DeltaBatch::VT_SEQ_END, seq_end, 0);
  }
  void add_events(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<md::FBBookDeltaEvent>>> events) {
    fbb_.AddOffset(DeltaBatch::VT_EVENTS, events);
  }
  explicit DeltaBatchBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DeltaBatch> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DeltaBatch>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DeltaBatch> CreateDeltaBatch(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> symbol = 0,
    uint64_t seq_start = 0,
    uint64_t seq_end = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<md::FBBookDeltaEvent>>> events = 0) {
  DeltaBatchBuilder builder_(_fbb);
  builder_.add_seq_end(seq_end);
  builder_.add_seq_start(seq_start);
  builder_.add_events(events);
  builder_.add_symbol(symbol);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<DeltaBatch> CreateDeltaBatchDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *symbol = nullptr,
    uint64_t seq_start = 0,
    uint64_t seq_end = 0,
    const std::vector<::flatbuffers::Offset<md::FBBookDeltaEvent>> *events = nullptr) {
  auto symbol__ = symbol ? _fbb.CreateString(symbol) : 0;
  auto events__ = events ? _fbb.CreateVector<::flatbuffers::Offset<md::FBBookDeltaEvent>>(*events) : 0;
  return md::CreateDeltaBatch(
      _fbb,
      symbol__,
      seq_start,
      seq_end,
      events__);
}

::flatbuffers::Offset<DeltaBatch> CreateDeltaBatch(::flatbuffers::FlatBufferBuilder &_fbb, const DeltaBatchT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OrderBookSnapshotT : public ::flatbuffers::NativeTable {
  typedef OrderBookSnapshot TableType;
  std::string symbol{};
  uint64_t seq = 0;
  std::vector<std::unique_ptr<md::OrderMsgLevelT>> buy_side{};
  std::vector<std::unique_ptr<md::OrderMsgLevelT>> sell_side{};
  uint64_t recent_trade_price = 0;
  uint32_t recent_trade_qty = 0;
  OrderBookSnapshotT() = default;
  OrderBookSnapshotT(const OrderBookSnapshotT &o);
  OrderBookSnapshotT(OrderBookSnapshotT&&) FLATBUFFERS_NOEXCEPT = default;
  OrderBookSnapshotT &operator=(OrderBookSnapshotT o) FLATBUFFERS_NOEXCEPT;
};

struct OrderBookSnapshot FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OrderBookSnapshotT NativeTableType;
  typedef OrderBookSnapshotBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SYMBOL = 4,
    VT_SEQ = 6,
    VT_BUY_SIDE = 8,
    VT_SELL_SIDE = 10,
    VT_RECENT_TRADE_PRICE = 12,
    VT_RECENT_TRADE_QTY = 14
  };
  const ::flatbuffers::String *symbol() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SYMBOL);
  }
  uint64_t seq() const {
    return GetField<uint64_t>(VT_SEQ, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<md::OrderMsgLevel>> *buy_side() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<md::OrderMsgLevel>> *>(VT_BUY_SIDE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<md::OrderMsgLevel>> *sell_side() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<md::OrderMsgLevel>> *>(VT_SELL_SIDE);
  }
  uint64_t recent_trade_price() const {
    return GetField<uint64_t>(VT_RECENT_TRADE_PRICE, 0);
  }
  uint32_t recent_trade_qty() const {
    return GetField<uint32_t>(VT_RECENT_TRADE_QTY, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SYMBOL) &&
           verifier.VerifyString(symbol()) &&
           VerifyField<uint64_t>(verifier, VT_SEQ, 8) &&
           VerifyOffset(verifier, VT_BUY_SIDE) &&
           verifier.VerifyVector(buy_side()) &&
           verifier.VerifyVectorOfTables(buy_side()) &&
           VerifyOffset(verifier, VT_SELL_SIDE) &&
           verifier.VerifyVector(sell_side()) &&
           verifier.VerifyVectorOfTables(sell_side()) &&
           VerifyField<uint64_t>(verifier, VT_RECENT_TRADE_PRICE, 8) &&
           VerifyField<uint32_t>(verifier, VT_RECENT_TRADE_QTY, 4) &&
           verifier.EndTable();
  }
  OrderBookSnapshotT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OrderBookSnapshotT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<OrderBookSnapshot> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const OrderBookSnapshotT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OrderBookSnapshotBuilder {
  typedef OrderBookSnapshot Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_symbol(::flatbuffers::Offset<::flatbuffers::String> symbol) {
    fbb_.AddOffset(OrderBookSnapshot::VT_SYMBOL, symbol);
  }
  void add_seq(uint64_t seq) {
    fbb_.AddElement<uint64_t>(OrderBookSnapshot::VT_SEQ, seq, 0);
  }
  void add_buy_side(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<md::OrderMsgLevel>>> buy_side) {
    fbb_.AddOffset(OrderBookSnapshot::VT_BUY_SIDE, buy_side);
  }
  void add_sell_side(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<md::OrderMsgLevel>>> sell_side) {
    fbb_.AddOffset(OrderBookSnapshot::VT_SELL_SIDE, sell_side);
  }
  void add_recent_trade_price(uint64_t recent_trade_price) {
    fbb_.AddElement<uint64_t>(OrderBookSnapshot::VT_RECENT_TRADE_PRICE, recent_trade_price, 0);
  }
  void add_recent_trade_qty(uint32_t recent_trade_qty) {
    fbb_.AddElement<uint32_t>(OrderBookSnapshot::VT_RECENT_TRADE_QTY, recent_trade_qty, 0);
  }
  explicit OrderBookSnapshotBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OrderBookSnapshot> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OrderBookSnapshot>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OrderBookSnapshot> CreateOrderBookSnapshot(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> symbol = 0,
    uint64_t seq = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<md::OrderMsgLevel>>> buy_side = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<md::OrderMsgLevel>>> sell_side = 0,
    uint64_t recent_trade_price = 0,
    uint32_t recent_trade_qty = 0) {
  OrderBookSnapshotBuilder builder_(_fbb);
  builder_.add_recent_trade_price(recent_trade_price);
  builder_.add_seq(seq);
  builder_.add_recent_trade_qty(recent_trade_qty);
  builder_.add_sell_side(sell_side);
  builder_.add_buy_side(buy_side);
  builder_.add_symbol(symbol);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<OrderBookSnapshot> CreateOrderBookSnapshotDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *symbol = nullptr,
    uint64_t seq = 0,
    const std::vector<::flatbuffers::Offset<md::OrderMsgLevel>> *buy_side = nullptr,
    const std::vector<::flatbuffers::Offset<md::OrderMsgLevel>> *sell_side = nullptr,
    uint64_t recent_trade_price = 0,
    uint32_t recent_trade_qty = 0) {
  auto symbol__ = symbol ? _fbb.CreateString(symbol) : 0;
  auto buy_side__ = buy_side ? _fbb.CreateVector<::flatbuffers::Offset<md::OrderMsgLevel>>(*buy_side) : 0;
  auto sell_side__ = sell_side ? _fbb.CreateVector<::flatbuffers::Offset<md::OrderMsgLevel>>(*sell_side) : 0;
  return md::CreateOrderBookSnapshot(
      _fbb,
      symbol__,
      seq,
      buy_side__,
      sell_side__,
      recent_trade_price,
      recent_trade_qty);
}

::flatbuffers::Offset<OrderBookSnapshot> CreateOrderBookSnapshot(::flatbuffers::FlatBufferBuilder &_fbb, const OrderBookSnapshotT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EnvelopeT : public ::flatbuffers::NativeTable {
  typedef Envelope TableType;
  md::BookMsgUnion msg{};
};

struct Envelope FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EnvelopeT NativeTableType;
  typedef EnvelopeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MSG_TYPE = 4,
    VT_MSG = 6
  };
  md::BookMsg msg_type() const {
    return static_cast<md::BookMsg>(GetField<uint8_t>(VT_MSG_TYPE, 0));
  }
  const void *msg() const {
    return GetPointer<const void *>(VT_MSG);
  }
  template<typename T> const T *msg_as() const;
  const md::DeltaBatch *msg_as_DeltaBatch() const {
    return msg_type() == md::BookMsg_DeltaBatch ? static_cast<const md::DeltaBatch *>(msg()) : nullptr;
  }
  const md::OrderBookSnapshot *msg_as_OrderBookSnapshot() const {
    return msg_type() == md::BookMsg_OrderBookSnapshot ? static_cast<const md::OrderBookSnapshot *>(msg()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MSG_TYPE, 1) &&
           VerifyOffset(verifier, VT_MSG) &&
           VerifyBookMsg(verifier, msg(), msg_type()) &&
           verifier.EndTable();
  }
  EnvelopeT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EnvelopeT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Envelope> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const EnvelopeT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const md::DeltaBatch *Envelope::msg_as<md::DeltaBatch>() const {
  return msg_as_DeltaBatch();
}

template<> inline const md::OrderBookSnapshot *Envelope::msg_as<md::OrderBookSnapshot>() const {
  return msg_as_OrderBookSnapshot();
}

struct EnvelopeBuilder {
  typedef Envelope Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_msg_type(md::BookMsg msg_type) {
    fbb_.AddElement<uint8_t>(Envelope::VT_MSG_TYPE, static_cast<uint8_t>(msg_type), 0);
  }
  void add_msg(::flatbuffers::Offset<void> msg) {
    fbb_.AddOffset(Envelope::VT_MSG, msg);
  }
  explicit EnvelopeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Envelope> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Envelope>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Envelope> CreateEnvelope(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    md::BookMsg msg_type = md::BookMsg_NONE,
    ::flatbuffers::Offset<void> msg = 0) {
  EnvelopeBuilder builder_(_fbb);
  builder_.add_msg(msg);
  builder_.add_msg_type(msg_type);
  return builder_.Finish();
}

::flatbuffers::Offset<Envelope> CreateEnvelope(::flatbuffers::FlatBufferBuilder &_fbb, const EnvelopeT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline FBBookDeltaEventT *FBBookDeltaEvent::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FBBookDeltaEventT>(new FBBookDeltaEventT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FBBookDeltaEvent::UnPackTo(FBBookDeltaEventT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = kind(); _o->kind = _e; }
  { auto _e = order_id(); _o->order_id = _e; }
  { auto _e = price(); _o->price = _e; }
  { auto _e = qty(); _o->qty = _e; }
  { auto _e = side(); _o->side = _e; }
  { auto _e = seq(); _o->seq = _e; }
}

inline ::flatbuffers::Offset<FBBookDeltaEvent> FBBookDeltaEvent::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FBBookDeltaEventT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFBBookDeltaEvent(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<FBBookDeltaEvent> CreateFBBookDeltaEvent(::flatbuffers::FlatBufferBuilder &_fbb, const FBBookDeltaEventT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const FBBookDeltaEventT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _kind = _o->kind;
  auto _order_id = _o->order_id;
  auto _price = _o->price;
  auto _qty = _o->qty;
  auto _side = _o->side;
  auto _seq = _o->seq;
  return md::CreateFBBookDeltaEvent(
      _fbb,
      _kind,
      _order_id,
      _price,
      _qty,
      _side,
      _seq);
}

inline OrderMsgOrderT *OrderMsgOrder::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<OrderMsgOrderT>(new OrderMsgOrderT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void OrderMsgOrder::UnPackTo(OrderMsgOrderT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; }
  { auto _e = qty(); _o->qty = _e; }
  { auto _e = side(); _o->side = _e; }
}

inline ::flatbuffers::Offset<OrderMsgOrder> OrderMsgOrder::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const OrderMsgOrderT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOrderMsgOrder(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<OrderMsgOrder> CreateOrderMsgOrder(::flatbuffers::FlatBufferBuilder &_fbb, const OrderMsgOrderT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const OrderMsgOrderT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _qty = _o->qty;
  auto _side = _o->side;
  return md::CreateOrderMsgOrder(
      _fbb,
      _id,
      _qty,
      _side);
}

inline OrderMsgLevelT::OrderMsgLevelT(const OrderMsgLevelT &o)
      : price(o.price) {
  orders.reserve(o.orders.size());
  for (const auto &orders_ : o.orders) { orders.emplace_back((orders_) ? new md::OrderMsgOrderT(*orders_) : nullptr); }
}

inline OrderMsgLevelT &OrderMsgLevelT::operator=(OrderMsgLevelT o) FLATBUFFERS_NOEXCEPT {
  std::swap(price, o.price);
  std::swap(orders, o.orders);
  return *this;
}

inline OrderMsgLevelT *OrderMsgLevel::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<OrderMsgLevelT>(new OrderMsgLevelT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void OrderMsgLevel::UnPackTo(OrderMsgLevelT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = price(); _o->price = _e; }
  { auto _e = orders(); if (_e) { _o->orders.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->orders[_i]) { _e->Get(_i)->UnPackTo(_o->orders[_i].get(), _resolver); } else { _o->orders[_i] = std::unique_ptr<md::OrderMsgOrderT>(_e->Get(_i)->UnPack(_resolver)); } } } else { _o->orders.resize(0); } }
}

inline ::flatbuffers::Offset<OrderMsgLevel> OrderMsgLevel::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const OrderMsgLevelT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOrderMsgLevel(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<OrderMsgLevel> CreateOrderMsgLevel(::flatbuffers::FlatBufferBuilder &_fbb, const OrderMsgLevelT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const OrderMsgLevelT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _price = _o->price;
  auto _orders = _o->orders.size() ? _fbb.CreateVector<::flatbuffers::Offset<md::OrderMsgOrder>> (_o->orders.size(), [](size_t i, _VectorArgs *__va) { return CreateOrderMsgOrder(*__va->__fbb, __va->__o->orders[i].get(), __va->__rehasher); }, &_va ) : 0;
  return md::CreateOrderMsgLevel(
      _fbb,
      _price,
      _orders);
}

inline DeltaBatchT::DeltaBatchT(const DeltaBatchT &o)
      : symbol(o.symbol),
        seq_start(o.seq_start),
        seq_end(o.seq_end) {
  events.reserve(o.events.size());
  for (const auto &events_ : o.events) { events.emplace_back((events_) ? new md::FBBookDeltaEventT(*events_) : nullptr); }
}

inline DeltaBatchT &DeltaBatchT::operator=(DeltaBatchT o) FLATBUFFERS_NOEXCEPT {
  std::swap(symbol, o.symbol);
  std::swap(seq_start, o.seq_start);
  std::swap(seq_end, o.seq_end);
  std::swap(events, o.events);
  return *this;
}

inline DeltaBatchT *DeltaBatch::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<DeltaBatchT>(new DeltaBatchT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DeltaBatch::UnPackTo(DeltaBatchT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = symbol(); if (_e) _o->symbol = _e->str(); }
  { auto _e = seq_start(); _o->seq_start = _e; }
  { auto _e = seq_end(); _o->seq_end = _e; }
  { auto _e = events(); if (_e) { _o->events.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->events[_i]) { _e->Get(_i)->UnPackTo(_o->events[_i].get(), _resolver); } else { _o->events[_i] = std::unique_ptr<md::FBBookDeltaEventT>(_e->Get(_i)->UnPack(_resolver)); } } } else { _o->events.resize(0); } }
}

inline ::flatbuffers::Offset<DeltaBatch> DeltaBatch::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DeltaBatchT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDeltaBatch(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<DeltaBatch> CreateDeltaBatch(::flatbuffers::FlatBufferBuilder &_fbb, const DeltaBatchT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const DeltaBatchT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _symbol = _o->symbol.empty() ? 0 : _fbb.CreateString(_o->symbol);
  auto _seq_start = _o->seq_start;
  auto _seq_end = _o->seq_end;
  auto _events = _o->events.size() ? _fbb.CreateVector<::flatbuffers::Offset<md::FBBookDeltaEvent>> (_o->events.size(), [](size_t i, _VectorArgs *__va) { return CreateFBBookDeltaEvent(*__va->__fbb, __va->__o->events[i].get(), __va->__rehasher); }, &_va ) : 0;
  return md::CreateDeltaBatch(
      _fbb,
      _symbol,
      _seq_start,
      _seq_end,
      _events);
}

inline OrderBookSnapshotT::OrderBookSnapshotT(const OrderBookSnapshotT &o)
      : symbol(o.symbol),
        seq(o.seq),
        recent_trade_price(o.recent_trade_price),
        recent_trade_qty(o.recent_trade_qty) {
  buy_side.reserve(o.buy_side.size());
  for (const auto &buy_side_ : o.buy_side) { buy_side.emplace_back((buy_side_) ? new md::OrderMsgLevelT(*buy_side_) : nullptr); }
  sell_side.reserve(o.sell_side.size());
  for (const auto &sell_side_ : o.sell_side) { sell_side.emplace_back((sell_side_) ? new md::OrderMsgLevelT(*sell_side_) : nullptr); }
}

inline OrderBookSnapshotT &OrderBookSnapshotT::operator=(OrderBookSnapshotT o) FLATBUFFERS_NOEXCEPT {
  std::swap(symbol, o.symbol);
  std::swap(seq, o.seq);
  std::swap(buy_side, o.buy_side);
  std::swap(sell_side, o.sell_side);
  std::swap(recent_trade_price, o.recent_trade_price);
  std::swap(recent_trade_qty, o.recent_trade_qty);
  return *this;
}

inline OrderBookSnapshotT *OrderBookSnapshot::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<OrderBookSnapshotT>(new OrderBookSnapshotT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void OrderBookSnapshot::UnPackTo(OrderBookSnapshotT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = symbol(); if (_e) _o->symbol = _e->str(); }
  { auto _e = seq(); _o->seq = _e; }
  { auto _e = buy_side(); if (_e) { _o->buy_side.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->buy_side[_i]) { _e->Get(_i)->UnPackTo(_o->buy_side[_i].get(), _resolver); } else { _o->buy_side[_i] = std::unique_ptr<md::OrderMsgLevelT>(_e->Get(_i)->UnPack(_resolver)); } } } else { _o->buy_side.resize(0); } }
  { auto _e = sell_side(); if (_e) { _o->sell_side.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->sell_side[_i]) { _e->Get(_i)->UnPackTo(_o->sell_side[_i].get(), _resolver); } else { _o->sell_side[_i] = std::unique_ptr<md::OrderMsgLevelT>(_e->Get(_i)->UnPack(_resolver)); } } } else { _o->sell_side.resize(0); } }
  { auto _e = recent_trade_price(); _o->recent_trade_price = _e; }
  { auto _e = recent_trade_qty(); _o->recent_trade_qty = _e; }
}

inline ::flatbuffers::Offset<OrderBookSnapshot> OrderBookSnapshot::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const OrderBookSnapshotT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOrderBookSnapshot(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<OrderBookSnapshot> CreateOrderBookSnapshot(::flatbuffers::FlatBufferBuilder &_fbb, const OrderBookSnapshotT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const OrderBookSnapshotT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _symbol = _o->symbol.empty() ? 0 : _fbb.CreateString(_o->symbol);
  auto _seq = _o->seq;
  auto _buy_side = _o->buy_side.size() ? _fbb.CreateVector<::flatbuffers::Offset<md::OrderMsgLevel>> (_o->buy_side.size(), [](size_t i, _VectorArgs *__va) { return CreateOrderMsgLevel(*__va->__fbb, __va->__o->buy_side[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _sell_side = _o->sell_side.size() ? _fbb.CreateVector<::flatbuffers::Offset<md::OrderMsgLevel>> (_o->sell_side.size(), [](size_t i, _VectorArgs *__va) { return CreateOrderMsgLevel(*__va->__fbb, __va->__o->sell_side[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _recent_trade_price = _o->recent_trade_price;
  auto _recent_trade_qty = _o->recent_trade_qty;
  return md::CreateOrderBookSnapshot(
      _fbb,
      _symbol,
      _seq,
      _buy_side,
      _sell_side,
      _recent_trade_price,
      _recent_trade_qty);
}

inline EnvelopeT *Envelope::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<EnvelopeT>(new EnvelopeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Envelope::UnPackTo(EnvelopeT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = msg_type(); _o->msg.type = _e; }
  { auto _e = msg(); if (_e) _o->msg.value = md::BookMsgUnion::UnPack(_e, msg_type(), _resolver); }
}

inline ::flatbuffers::Offset<Envelope> Envelope::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const EnvelopeT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEnvelope(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Envelope> CreateEnvelope(::flatbuffers::FlatBufferBuilder &_fbb, const EnvelopeT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const EnvelopeT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _msg_type = _o->msg.type;
  auto _msg = _o->msg.Pack(_fbb);
  return md::CreateEnvelope(
      _fbb,
      _msg_type,
      _msg);
}

inline bool VerifyBookMsg(::flatbuffers::Verifier &verifier, const void *obj, BookMsg type) {
  switch (type) {
    case BookMsg_NONE: {
      return true;
    }
    case BookMsg_DeltaBatch: {
      auto ptr = reinterpret_cast<const md::DeltaBatch *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BookMsg_OrderBookSnapshot: {
      auto ptr = reinterpret_cast<const md::OrderBookSnapshot *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyBookMsgVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyBookMsg(
        verifier,  values->Get(i), types->GetEnum<BookMsg>(i))) {
      return false;
    }
  }
  return true;
}

inline void *BookMsgUnion::UnPack(const void *obj, BookMsg type, const ::flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case BookMsg_DeltaBatch: {
      auto ptr = reinterpret_cast<const md::DeltaBatch *>(obj);
      return ptr->UnPack(resolver);
    }
    case BookMsg_OrderBookSnapshot: {
      auto ptr = reinterpret_cast<const md::OrderBookSnapshot *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline ::flatbuffers::Offset<void> BookMsgUnion::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case BookMsg_DeltaBatch: {
      auto ptr = reinterpret_cast<const md::DeltaBatchT *>(value);
      return CreateDeltaBatch(_fbb, ptr, _rehasher).Union();
    }
    case BookMsg_OrderBookSnapshot: {
      auto ptr = reinterpret_cast<const md::OrderBookSnapshotT *>(value);
      return CreateOrderBookSnapshot(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline BookMsgUnion::BookMsgUnion(const BookMsgUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case BookMsg_DeltaBatch: {
      value = new md::DeltaBatchT(*reinterpret_cast<md::DeltaBatchT *>(u.value));
      break;
    }
    case BookMsg_OrderBookSnapshot: {
      value = new md::OrderBookSnapshotT(*reinterpret_cast<md::OrderBookSnapshotT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void BookMsgUnion::Reset() {
  switch (type) {
    case BookMsg_DeltaBatch: {
      auto ptr = reinterpret_cast<md::DeltaBatchT *>(value);
      delete ptr;
      break;
    }
    case BookMsg_OrderBookSnapshot: {
      auto ptr = reinterpret_cast<md::OrderBookSnapshotT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = BookMsg_NONE;
}

inline const md::Envelope *GetEnvelope(const void *buf) {
  return ::flatbuffers::GetRoot<md::Envelope>(buf);
}

inline const md::Envelope *GetSizePrefixedEnvelope(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<md::Envelope>(buf);
}

inline bool VerifyEnvelopeBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<md::Envelope>(nullptr);
}

inline bool VerifySizePrefixedEnvelopeBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<md::Envelope>(nullptr);
}

inline void FinishEnvelopeBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<md::Envelope> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedEnvelopeBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<md::Envelope> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<md::EnvelopeT> UnPackEnvelope(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<md::EnvelopeT>(GetEnvelope(buf)->UnPack(res));
}

inline std::unique_ptr<md::EnvelopeT> UnPackSizePrefixedEnvelope(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<md::EnvelopeT>(GetSizePrefixedEnvelope(buf)->UnPack(res));
}

}  // namespace md

#endif  // FLATBUFFERS_GENERATED_ORDERBOOK_MD_H_
